package com.ulyssecarion.pdb;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.biojava.bio.structure.Atom;
import org.biojava.bio.structure.Calc;
import org.biojava.bio.structure.Chain;
import org.biojava.bio.structure.Element;
import org.biojava.bio.structure.Group;
import org.biojava.bio.structure.Structure;
import org.biojava.bio.structure.StructureException;
import org.biojava.bio.structure.align.util.AtomCache;
import org.biojava.bio.structure.io.FileParsingParameters;
import org.biojava3.structure.StructureIO;

public class DistanceTablesBuilder {
	protected static final boolean VERBOSE = false;

	private static final double MIN_DISTANCE = 1.7; // angstroms

	// there are 64 bits to store into a long; each bit represents 0.1 A
	private static final double MAX_DISTANCE = MIN_DISTANCE + 6.3;

	private static AtomCache cache;

	static {
		cache = getCache();
	}

	/**
	 * Finds proteins that have occurrences of some pair of elements at at the
	 * distances specified. This method should not be confused with
	 * {@link #getMatchesInRange(Map, Element, Element, double, double)}, which
	 * takes a <code>Map&lt;String, Map&lt;String, Long>></code> instead of a
	 * <code>Map&lt;String, Long></code>. This method should be called if you
	 * have already acquired the distance map specific to your element pair
	 * because, for instance, you got this map from the
	 * {@link DistanceTableSerializer#deserialize(String)} method.
	 * 
	 * @param map
	 *            a map that takes PDB IDs and returns bitmaps of where some
	 *            element pairing occurs
	 * @param minDistance
	 *            the closest the elements can be to each other, in angstroms.
	 *            This value must be larger than {@value #MIN_DISTANCE}.
	 * @param maxDistance
	 *            the farthest the elements can be to each other, in angstroms.
	 *            This value must be less than {@value #MAX_DISTANCE}.
	 * @return a list of the PDB IDs that matched the search.
	 */
	public static List<String> getMatchesInRange(Map<String, Long> map,
			double minDistance, double maxDistance) {
		long bitmap = 0L;

		for (int i = asDistanceIndex(minDistance); i <= asDistanceIndex(maxDistance); i++) {
			bitmap |= 1L << i;
		}

		List<String> results = new ArrayList<>();
		for (String pdbId : map.keySet()) {
			if ((map.get(pdbId) & bitmap) != 0L)
				results.add(pdbId);
		}

		return results;
	}
	
	/**
	 * Finds proteins that have the passed pair of elements occurring between
	 * the distances specified.<br />
	 * 
	 * This method delegates to {@link #getMatchesInRange(Map, double, double)}.
	 * You may want to call this method directly if you have a
	 * <code>Map&lt;String, Long></code>, as opposed to a
	 * <code>Map&lt;String, Map&lt;String, Long>></code>, which this method
	 * takes.
	 * 
	 * @param map
	 *            the map generated by a call to {@link #buildTable(List)}
	 * @param a
	 *            an element to occur (at the moment, it must be a metal for any
	 *            chance of getting results)
	 * @param b
	 *            the other element to occur
	 * @param minDistance
	 *            the closest the elements can be to each other, in angstroms.
	 *            This value must be larger than {@value #MIN_DISTANCE}.
	 * @param maxDistance
	 *            the farthest the elements can be to each other, in angstroms.
	 *            This value must be less than {@value #MAX_DISTANCE}.
	 * @return a list of the PDB IDs that matched the search.
	 */
	public static List<String> getMatchesInRange(
			Map<String, Map<String, Long>> map, Element a, Element b,
			double minDistance, double maxDistance) {
		String key = a + "" + b;

		if (!map.containsKey(key)) {
			return new ArrayList<>();
		}

		return getMatchesInRange(map.get(key), minDistance, maxDistance);
	}

	/**
	 * Constructs a new Map that, in conjunction with
	 * {@link #getMatchesInRange(Map, Element, Element, double, double)}, can be
	 * used to find proteins that have particular element pairs occurring within
	 * specific distance ranges. The rest of this documentation is most likely
	 * irrelevant to you unless you don't intend to simply use
	 * getMatchesInRange.<br />
	 * 
	 * Constructs a new Map that takes pairs of Elements concatenated together
	 * (i.e. Au + C becomes "AuC") and returns other maps, which in turn take
	 * PDB IDs and return a bitmap representing the distances at which the given
	 * pairing (i.e. "AuC") occur together in the protein.<br />
	 * 
	 * For example, if this method returns some map <code>m</code>, then
	 * <code>m.get("NaCl")</code> would return a map helping you find proteins
	 * that have Sodium and Chlorine near each other.
	 * <code>m.get("NaCl").get("1ABC")</code> would return a long. The bits that
	 * are set "on" in that long indicate the distances between which Sodium and
	 * Chlorine atoms were found in the protein.<br />
	 * 
	 * This search will exclude matches that are due to atoms in the same
	 * Biojava {@link org.biojava.bio.structure.Group Group}.
	 * 
	 * @param pdbIds
	 *            a list of PDB IDs to look through. If you don't put a PDB in
	 *            here, you'll never get it as a result.
	 * @return a map that takes element pairs and returns maps that take PDB IDs
	 *         and return bitmaps indicating distances at which said element
	 *         pairs occur in said proteins.
	 */
	public static Map<String, Map<String, Long>> buildTable(List<String> pdbIds) {
		StructureIO.setAtomCache(cache);

		// this one is: PDB -> (elements -> bitmap)
		Map<String, Map<String, Long>> pdbToElemMap = new HashMap<>();
		for (String pdbId : pdbIds) {
			pdbToElemMap.put(pdbId, buildTableFor(pdbId));
		}

		if (VERBOSE)
			System.out.println("Done processing tables, now reformatting.");

		return reformatMap(pdbToElemMap);
	}

	/**
	 * Takes a map of the form
	 * 
	 * <pre>
	 * 	PDB --> Element Pair --> Bitmap
	 * </pre>
	 * 
	 * and converts it to a map of the form
	 * 
	 * <pre>
	 * 	Element Pair --> PDB --> Bitmap
	 * </pre>
	 * 
	 * This is a necessary operation for converting the results of
	 * {@link #buildTableFor(String)} into what's returned by
	 * {@link #buildTable(List)}.
	 * 
	 * @param pdbToElemMap
	 *            a map that takes PDB IDs and returns element pair-taking maps
	 * @return a map that takes element pairs and returns PDB ID-taking maps.
	 */
	public static Map<String, Map<String, Long>> reformatMap(
			Map<String, Map<String, Long>> pdbToElemMap) {
		// let's convert PDB -> (elements -> bitmap)
		// to: elements -> (PDB -> bitmap)
		Map<String, Map<String, Long>> result = new HashMap<>();
		for (String pdbId : pdbToElemMap.keySet()) {
			if (VERBOSE)
				System.out.println("Reformatting for " + pdbId);

			Map<String, Long> elementToBitmap = pdbToElemMap.get(pdbId);

			for (String elementPair : elementToBitmap.keySet()) {
				long bitmap = elementToBitmap.get(elementPair);

				if (result.containsKey(elementPair)) {
					result.get(elementPair).put(pdbId, bitmap);
				} else {
					result.put(elementPair, new HashMap<String, Long>());
					result.get(elementPair).put(pdbId, bitmap);
				}
			}
		}

		return result;
	}

	/**
	 * Builds a table for an individual protein by its PDB ID. The result of
	 * this method is a map that takes element pairs concatenated together into
	 * strings (i.e. Na + C becomes "NaC") and returns bitmaps indicating at
	 * which distances those pairings occurred.<br />
	 * 
	 * You are most likely better off using the
	 * {@link #matches(Map, Element, Element, double, double)} method provided
	 * for you than trying to manipulate this Map on your own.<br />
	 * 
	 * Do not confuse this method with the more powerful
	 * {@link #buildTable(List)} method, which does not quite do the same thing.
	 * 
	 * @see #buildTable(List)
	 * @param pdbId
	 *            the PDB ID to generate a map for
	 * @return a map that takes element pairs and returns bitmaps indicating
	 *         where said pairs occur in the protein passed.
	 */
	public static Map<String, Long> buildTableFor(String pdbId) {
		// XXX does this need to be done each time?
		StructureIO.setAtomCache(cache);

		Map<String, Long> result = new HashMap<>();

		int bioAssemblyCount = StructureIO.getNrBiologicalAssemblies(pdbId);
		int bioAssemblyId = bioAssemblyCount > 0 ? 1 : 0;

		Structure structure = null;
		try {
			structure = StructureIO.getBiologicalAssembly(pdbId, bioAssemblyId);
		} catch (IOException | StructureException e) {
			e.printStackTrace();
			throw new RuntimeException();
		}

		List<Atom> atoms = structureToAtomArray(structure);
		List<Group> ligands = getLigands(structure);

		// TODO this probably could be a bit faster; since we don't need to look
		// at cases where the two atoms' groups are the same, optimal would be
		// to not loop through that group at all. Probably just a 'continue'
		// would do, but at the moment that'd be premature optimization
		try {
			for (Atom a : atoms) {
				if (ligands.contains(a.getGroup())) { // it's a ligand
					for (Atom b : atoms) {
						if (a.getGroup() != b.getGroup()) {
							double distance = Calc.getDistance(a, b);

							if (distance >= MIN_DISTANCE
									&& distance <= MAX_DISTANCE) {
								updateMap(result, a, b,
										asDistanceIndex(distance));
							}
						}
					}
				}
			}
		} catch (StructureException e) {
			e.printStackTrace();
			throw new RuntimeException();
		}

		return result;
	}

	/**
	 * A Group is a ligand if it is a group found with
	 * {@link Chain#getAtomGroups()} but not {@link Chain#getSeqResGroups()}.
	 * 
	 * @param structure
	 *            the structure to get ligands from
	 * @return the ligand groups in the structure
	 */
	private static List<Group> getLigands(Structure structure) {
		List<Group> ligands = new ArrayList<>();

		for (int i = 0; i < structure.nrModels(); i++) {
			List<Chain> model = structure.getModel(i);

			for (Chain chain : model) {
				List<Group> allGroups = chain.getAtomGroups();
				List<Group> seqResGroups = chain.getSeqResGroups();

				for (Group group : allGroups) {
					if (!seqResGroups.contains(group)
							&& !group.getPDBName().equals("HOH"))
						ligands.add(group);
				}
			}
		}

		return ligands;
	}

	/**
	 * Adds a particular pairing as having occurred at some distance index.
	 * 
	 * @param result
	 *            the map to add to
	 * @param a
	 *            the first element occurring
	 * @param b
	 *            the second element occurring
	 * @param distanceIndex
	 *            the distance index at which the event occurred (so make sure
	 *            you call {@link #asDistanceIndex(double)} first)
	 */
	private static void updateMap(Map<String, Long> result, Atom a, Atom b,
			int distanceIndex) {
		String key = a.getElement() + "" + b.getElement();
		long bitmap = 1L << distanceIndex;

		if (result.containsKey(key)) {
			long prevValue = result.get(key);

			result.put(key, prevValue | bitmap);
		} else {
			result.put(key, bitmap);
		}
	}

	/*
	 * A note about this method: because in previous code we limit ourselves to
	 * one specific biological assembly, we might not get all the atoms of a
	 * protein here; some biological assemblies may only have some of the chains
	 * found in the complete protein.
	 * 
	 * TODO use getAtomLigands() once it's part of biojava
	 */
	private static List<Atom> structureToAtomArray(Structure structure) {
		ArrayList<Atom> atoms = new ArrayList<Atom>();

		for (int i = 0; i < structure.nrModels(); i++) {
			List<Chain> model = structure.getModel(i);

			for (Chain chain : model) {
				for (Group group : chain.getAtomGroups()) {
					for (Atom a : group.getAtoms()) {
						atoms.add(a);
					}
				}
			}
		}

		return atoms;
	}

	/**
	 * Determines if a protein has a particular pairing of elements occurring at
	 * some range specified.
	 * 
	 * @param map
	 *            the map generated by {@link #buildTableFor(String)}
	 * @param a
	 *            an element to occur (at the moment, this must be a metal for
	 *            any possibility of results)
	 * @param b
	 *            the other element to occur
	 * @param minDistance
	 *            the minimum distance between the two elements, in angstroms
	 *            (this must be greater than {@value #MIN_DISTANCE}.
	 * @param maxDistance
	 *            the maximum distance between the two elements, in angstroms
	 *            (this must be less than {@value #MAX_DISTANCE}.
	 * @return if the passed constraints are all met.
	 */
	public static boolean matches(Map<String, Long> map, Element a, Element b,
			double minDistance, double maxDistance) {
		long bitmap = 0L;

		for (int i = asDistanceIndex(minDistance); i <= asDistanceIndex(maxDistance); i++)
			bitmap |= 1L << i;

		String key = a + "" + b;

		if (!map.containsKey(key))
			return false;

		return (map.get(key) & bitmap) != 0L;
	}

	/**
	 * Converts a distance in angstroms to an index (0-63, inclusive). Said
	 * index "i" represents the i-th bit in a bitmap for representing distances
	 * at which some pairing occurs.<br />
	 * 
	 * @throws RuntimeException
	 *             if the passed distance is not between MIN_DISTANCE and
	 *             MAX_DISTANCE.
	 * @param distance
	 *            the distance between some two atoms
	 * @return the corresponding index in a bitmap
	 */
	private static int asDistanceIndex(double distance) {
		if (distance < MIN_DISTANCE)
			throw new RuntimeException("Out of bounds: " + distance
					+ " must be greater than or equal to " + MIN_DISTANCE);
		if (distance > MAX_DISTANCE)
			throw new RuntimeException("Out of bounds: " + distance
					+ " must be less than or equal to " + MAX_DISTANCE);

		return (int) ((distance - MIN_DISTANCE) * 10);
	}

	private static AtomCache getCache() {
		AtomCache cache = new AtomCache();
		FileParsingParameters params = cache.getFileParsingParams();
		params.setStoreEmptySeqRes(true);
		params.setAlignSeqRes(true);
		params.setLoadChemCompInfo(true);

		return cache;
	}
}
